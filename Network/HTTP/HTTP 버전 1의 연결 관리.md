# HTTP 1.x의 연결 관리
### HTTP 1.x에서 통신 방법
HTTP 1.x에서는 단기 연결, 영구 연결 및 HTTP 파이프라이닝과 같은 모델이 존재한다.

### 단기 연결과 단기 연결의 문제점
HTTP 프토토콜은 클라이언트와 서버 간 연결을 제공하는 전송 프로토콜인 TCP에 의존한다. 초기 HTTP 1.0 이하 버전은 단일 통신 연결을 사용해 연결을 처리하다 보니 통신 수명이 매우 짧았다. 즉, 요청을 보내야할 때마다 새로운 연결이 생성되고, 응답이 수신되면 닫히는 구조였다.

### 단기 연결의 문제점 정리
1. TCP 연결은 통신을 하기 위해서 클라이언트와 서버 간 여러 메시지를 교환해야 한다는 비효율이 있다.
2. 매 요청마다 네트워크 대기 시간을 기다리며,  대역폭을 설정하며 요청을 보내게 된다면 성능에 영향을 주게 된다.
3. 최신 웹 페이지는 많은 양의 데이터를 제공하게 되는데, 이 때 필요한 데이터만큼의 요청을 보내게 된다. 동일한 서버에서 요청을 처리할 때마다 연결과 연결 종료를 반복하는 초기 모델을 사용하게 된다면 비효율적이다.

### 단방향 문제를 해결하는 HTTP 1.1 모델에서 모델
이 방식을 해결하기 위해 HTTP 1.1 모델에서는 두 개의 새로운 모델이 탄생했다. 지속적 연결인 영구 연결 모델은 연속적인 요청 간의 연결을 영구적으로 열어 새 요청을 하는 시간을 줄이고 자원도 줄일 수 있다. HTTP 파이프라이닝 모델은 한 단계 더 나아가 응답을 기다리지 않고 여러 개의 연속적인 요청을 보내 네트워크 대기 시간을 효과적으로 줄일 수 있다.


![이미지](/Network/HTTP/1.png)
    

> HTTP 2에서는 연결 관리를 위해 모델이 추가되었다.

HTTP의 연결 관리는 두 개의 연속 노드 사이 연결에 적용되며 end-to-end point 간 연결이 아닌 hop-by-hop 연결에 적용된다는 점에 유의해야 한다. 

> [🛠 HTTP Header(수정중)](/Network/HTTP/HTTP%20Header(%EC%88%98%EC%A0%95%EC%A4%91).md)에서 end-to-end와 hop-by-hop과 관련된 정보를 볼 수 있다.

클라이언트와 첫 번째 프록시 간 연결에 사용되는 모델은 프록시와 대상 서버간의 모델과 다를 수 있다. `Connection` 및 `Keep-Alive`와 같이 연결 모델을 정의하는 데 관련된 HTTP 헤더는 중간 노드에서 값을 변경할 수 있는 hop-by-hop 헤더이며, 서버간 모델이 다를 수 있는 부분을 hop-by-hop 헤더를 사용하게 된다면 값을 수정해 해결할 수 있다.

### 단기 연결(Short-lived connections)

**단기 연결이란?**
HTTP 1.0 이전 모델은 수명이 짧은 연결이다. 각 요청마다 연결과 연결 종료 동작을 진행하기 때문에 각 HTTP 요청 전에 TCP 핸드셰이크가 발생하고 직렬화된다. 

**단기 연결에서 문제점**
TCP 핸드셰이크 자체는 시간이 많이 걸리지만 TCP 연결은 지속적이고 안정적인 연결이 가능하기에 효율적이다. 그러나 단기 연결은 TCP의 이러한 효율적인 기능을 사용하지 않고 계속 새로운 연결을 시도하기에 최적화될 수 없는 구조이다.

> HTTP 1.0에서는 `Connection` 헤더가 없거나 `close`로 설졍된 경우도 단기 연결로 전송된다. HTTP 1.1 경우에는 `Connection`이 `close`일 경우에만 단기 연결로 전송된다.

> 영구 연결을 지원하지 않는 오래된 시스템을 다루지 않는 한 이 모델을 사용하지 않는다.

### 영구 연결(Persistent connections)

**영구 연결이란?**
단기 연결에는 두 가지 문제가 있다. 새 연결을 설정하는데 시간이 많이 소요된다는 점이고, 기본 TCP 연결의 성능은 일정 시간 유지되었을 때 효과적이기 때문이다. 이런 문제를 해결하기 위해 HTTP 1.1 버전에서는 영구 연결 개념이 설계되어졌다.

**영구 연결에서 이점**
영구 연결은 TCP 핸드셰이크 횟수를 줄이고 이로 인해 TCP 성능 향상 기능을 활용한다.

> TCP 연결은 높은 대기 시간을 가진 네트워크에서 대역폭을 지원하고 있다.

이 연결은 열린 상태로 유지되지 않고 유휴 상태에서 인정 시간이 지나면 닫힌다. 서버는 Keep-Alive 헤더 사용으로 최소 연결 지속 상태를 설정할 수 있다.

**영구 연결의 단점**
유휴 상태에서 서버 자원을 소모해 과부화 상태를 만드는 Dos 공격이 가능해진다. 이러한 경우 유휴 상태가 되자마자 닫히는 비영구적 연결을 사용하면 더 나은 성능을 제공할 수 있다.

> HTTP 1.0 연결은 기본적으로 지속되지 않지만, `Connection`을 `close retry-after`로 설정한다면 영구적으로 설정할 수 있다.
> HTTP 1.1에서는 지속성이 기본값이기 때문에 헤더는 필요하지 않지만 HTTP 1.0을 대체하는 상황을 방어하기 위해 추가되는 경우가 많다.


### 파이프라이닝(HTTP pipelining)

> 파이프라이닝은 최신 브라우저에서 기본적으로 활성화되지 않는다. 

**활성화 되지 않는 이유**

- 버그가 있는 프록시는 불규칙적으로 동작하기 때문에 웹 개발자가 쉽게 예측하고 진단할 수 없다.
- 왕복 시간 및 유효 대역폭을 고려하지 않으면 메시지 순서가 올바르게 전송되지 않기 때문에 파이프라이닝을 올바르게 구현하기 어렵다.
- 파이프라이닝을 [HOL](https://en.wikipedia.org/wiki/Head-of-line_blocking)(Head-of-line blocking) 문제의 영향을 받는다.

> 이러한 이유로 파이프라이닝을 HTTP 2에서 사용되는 [[Multiplexing(수정중)]]으로 대체되었다.

**파이프라이닝이란**

기본적인 HTTP 요청은 다음 요청을 보내기 위해 이전 응답을 기다려야 하는데, 네트워크 대기 시간 및 대역폭 제한의 영향을 받게 된다. 그러나 파이프 라이닝은 응답을 기다리지 않고 동일한 영구 연결(Persistent connections)을 통해 연속적인 요청을 보내는 방식이다. 

이론적으로 두 개의 HTTP 요청이 동일한 TCP 메시지로 압축되는 경우에도 성능이 향상될 수 있다. 일반적인 MSS(Maximum Segment Size)는 HTTP 요청의 크기에 대한 수요가 계속 증가하지만, 여러 간단한 요청을 압축할 만큼 충분히 크다.

**파이프라이닝 주의점**

파이프라인으로 통신할 수 있는 요청을 멱등성의 특징을 가진 메서드만이다. 즉, GET, HEAD, PUT 그리고 DELETE 만이 안정하게 파이프라인에서 동작한다. 장애가 발생하게 되면 재요청이 되기 때문에 콘텐츠가 반복될 가능서잉 있다.


### Domain sharding

> 이 기술을 사용하지 말고 HTTP 2로 전환하는것이 좋다. HTTP 2는 병렬 요청을 매우 잘 처리할 수 있다. 도메인 샤딩은 성능에도 악영향을 미친다.

**병렬 요청을 보내기 위해**

HTTP 1.x 연결은 요청을 직렬화하므로 순서가 없더라도 사용 가능한 대역폭이 충분하지 않으면 최적화할 수 없다. 이 방법의 솔루션으로 브라우저는 각 도메인에 대한 여러 연결을 열어 병렬 요청을 보낸다.

**도메인 샤딩이란**

서버가 더 빠른 웹 사이트 또는 응용 프로그램 응답을 원하는 경우 서버에서 더 많은 연결을 강제로 열 수 있다. 예를 들어 동일한 도메인에 모든 리소스가 있는 대신 여러 도메인을 동일한 서버로 여는 방법이다. 이 기술을 Domain sharding 이라 한다.

> 병렬 연결을 통로를 많이 증설 할 수록 병렬 요청을 잘 처리하게 되겠지만 Dos 보호가 유발될 위험이 있다.

### 마지막으로
향상된 연결 관리를 통해 HTTP의 성능을 크게 높일 수가 있다. HTTP/1.x는 최소한 유휴 상태가 될 때까지 지속적인 연결을 사용하게 된다면 최상위 성능을 얻게 된다. 그러나 파이프라이닝의 실패로 인해 HTTP/2에 통합된 연결 관리 모델이 설계되었다.

### 참고자료
[MDN : HTTP/1.x의 연결 관리](https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x)
[Wiki : HOL](https://en.wikipedia.org/wiki/Head-of-line_blocking)
[Wiki : RTD or RTT](https://en.wikipedia.org/wiki/Round-trip_delay)