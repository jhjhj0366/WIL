## 목차
1. 문자열 인코딩이란
2. 아스키 코드(ASCII)
3. EUC-KR(CP949)
4. 유니코드(UTF-8, UTF-16, UTF-32)
5. UTF-8
6. UTF-16
7. 마치며

## 문자열 인코딩이란

### 문자열 인코딩이란
문자열 인코딩이란 2진법을 사용한 컴퓨터가 인간의 언어를 일정한 규칙에 따라 2진수로 변환하는 방식이다.

### 문자열이 깨지는 이유
글자가 깨지거나 보이지 않는 문제가 발생하는 이유는 호환되지 않는 문자열 인코딩을 사용해 문자열을 읽었기 때문이다.

> 여러 규칙 중 어느 것을 적용하는지에 따라 글자가 올바르게 보일 수도 글자가 깨져보일 수 있다.

### 문자 집합(charset)
문자 집합은 사용할 수 있는 문자들의 집합을 말한다. 대표적으로 아스키코드, 유니코드 등을 분류할 때 나타낼 수 있다.

### 문자열 인코딩
문자열 인코딩은 문자를 코드로 표현하는 방식을 말한다. 유니코드 문자 집합을 표현하는 문자열 인코딩은 UTF-8, UTF-16, UTF-32 이다.

## 아스키 코드(ASCII)

### 아스키 코드
- 아스키 코드는 처음으로 표준을 정립한 문자열 인코딩 방식이다.
- 아직까지 많이 사용된다.
- 총 128 개의 숫자를 사용한다.
- 영어를 제외한 다른 언어를 표현할 수 없다.

### 아스키 코드는 문자열이다.

> 컴퓨터는 2 진수 데이터를 문자나 숫자로만 표현할 수 있기 때문에 숫자 또한 문자열로 표현한다.

### 아스키 코드는 7비트만 사용하지만 8비트가 할당된다.

> 과거에는 7비트만 사용했지만, 현대 운영체제들은 성능 향상과 편의를 위해 8비트를 사용해 아스키 코드를 표현한다. (메모리 4바이트 정렬 관련)

### 아스키 코드의 단점

아스키 코드로는 모든 문자를 표현할 수 없기  때문에 각 문자별로 독자적인 문자 집합과 인코딩 방식을 만들어 사용했다.

## EUC-KR(CP949)

### EUC-KR
- EUC-KR은 한국 산업 표준으로 지정된 한국어 문자 집합이다.
- 문자 하나를 표현하기 위해 2 바이트를 사용한다.
- 아스키 코드 문자는 1 바이트만 사용하기 때문에 아스키 코드와 호환 가능하다.

### EUC-KR은 완성형 코드이다.

EUC-KR은 모든 글자가 완성된 형태로만 존재하는 완성형 코드이기 때문에 초성, 중성, 종성을 조합해 문자를 만들 수 없다.

> EUC-KR로 표현할 수 없는 한글이 일부 존재한다.

### EUC-KR와 CP949

CP949는 EUC-KR을 확장한 문자 집합으로 EUC-KR과 같은 문자열 인코딩이나 더 많은 문자열을 표현할 수 있다.

### EUC-KR는 2바이트로 문자를 표현한다.

EUC-KR는 2 바이트로 문자 하나를 표현하기 때문에 실제 문자열 길이가 버퍼 길이와 다른 경우가 많다.

> 개발 환경에서 문자열 길이와 버퍼 크기를 동일하게 취급해 생기는 문제가 많은니 주의하자

> 버퍼는 메모리에 할당된 공간을 의미한다.

## 유니코드

### 유니코드
국가별로 독자적인 문자열 인코딩을 사용하는 문제를 해결하기 위해 국제 표준화 기구에서 동일한 규칙으로 모든 언어를 표현할 수 있는 유니코드 문자 집합을 만들었다.

### 유니코드 문자열 인코딩
유니코드 문자열 인코딩 방식은 총 세 가지로 UTF-8, UTF-16, UTF-32가 있다. 그 중 UTF-8, UTF-16가 많이 사용된다.

## UTF-8
### UTF-8
- 8비트로 인코딩하는 것을 의미한다.
- 아스키 코드와 완벽하게 호환된다.
- 표현하려는 문자에 따라 최소 1 바이트에서 최대 6 바이트까지 사용한다.

### UTF-8 규칙
UTF-8는 각 바이트마다 표현하는 규칙을 이용해 몇 바이트를 활용해 문자를 표현하는지 추측한다. 예를들어 비트 앞 숫자가 0이라면 1바이트로 표현된 문자를 의미한다.

1 바이트 : 0XXXXXXX
2 바이트 : 110XXXXX 10XXXXXX
3 바이트 : 1110XXXX 10XXXXXX 10XXXXXX
4 바이트  11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
5 바이트 : 111110XXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
6 바이트 : 1111110XX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX

> 보통 일반적인 문자는 3 바이트 내로 처리되며 4 바이트 영역에는 이모지 같은 문자가 있다. 5 바이트 이상을 쓰는 경우는 거의 없다.

## UTF-16

### UTF-16
- 16비트로 인코딩하는 것을 의미한다.
- 2 바이트 또는 4 바이트만 사용한다.
- 아스키 코드와 호환되지 않는다.

### 바이트 크기를 나누는 기준
유니코드에는 문자 종류에 따라 기본 다국어 평면(BMP), 보충 다국어 평면(SMP), 상형 문자 보충 평(SIP), 특수 목적 보충 평면(SSP) 등 평면 4개가 있고, 바이트 수는 표현하려는 문자가 어떤 평면에 속하는지에 따라 결정된다.

### 2 바이트로 표현
BMP에는 한글, 한자를 포함한 여러 다국어가 있고, 2 바이트로 인코딩된다.

### 4 바이트로 표현
BMP 범위를 벗어나는 문자들은 4 바이트로 인코딩한다. 구분하는 기준은 처음 읽는 2바이트는 `110110`으로 시작하고, 이후에 읽는 2바이트는 `110111`으로 시작해야 한다.

> 리틀 엔디언 기준으로 두 번째 바이트가 `110110`으로 시작하면 2 바이트 대신 4 바이트로 읽어 처리한다. 이 때 뒤에 오는 2 바이트는 `110111`로 시작해야 한다.

4 바이트 표현 빅 엔디언 : `110110xx xxxxxxxx 110111xx xxxxxxxx`
4 바이트 표현 리틀 엔디언 : `110111xx xxxxxxxx 110110xx xxxxxxxx`

### 바이트 순서 표시(Byte order mark - BOM)
- UTF-16과 UTF-32는 바이트 순서 표시를 사용한다.
- BOM은 문자열 가장 맨 앞에 2 바이트인 0xFEFF로 표기해 사용한다.
- 0xFE와 0xFF 중 어떤 문자가 오는지에 따라 리틀 앤디언과 빅 앤디언으로 나뉜다.
- 0xFE를 먼저 읽으면 빅 엔디언이다.
- 0xFF를 먼저 읽으면 리틀 엔디언이다.

> UTF-8도 BOM에 해당하는 값이 있지만, 1 바이트 단위로 글자를 변환하기 때문에 글자를 읽는 순서가 달라도 영향을 받지 않는다. 심지어 JSON 규격은 BOM을 허용하지 않는다.

## UTF-32
### UTF-32
- UTF-32는 모든 문자를 고정된 4 바이트 길이로 사용한다.
- UTF-16과 동일한 규칙을 사용한다.
### UTF-32는 사용하지 않는다.
UTF-32는 UTF-16보다 더 많은 바이트만 사용하는 것외에는 별다른 특징이 없기 때문에 UTF-32 사용이 줄고 있다.

## 마치며
- UTF-8
- UTF-16
- UTF-32
- ECU-KR
