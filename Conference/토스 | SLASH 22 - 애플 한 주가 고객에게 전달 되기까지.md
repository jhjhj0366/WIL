# SLASH 22 - 애플 한 주가 고객에게 전달 되기까지

## 영상

[토스ㅣSLASH 22 - 애플 한 주가 고객에게 전달 되기까지](https://www.youtube.com/watch?v=UOWy6zdsD-c&list=PL1DJtS1Hv1PiGXmgruP1_gM2TSvQiOsFL&index=10)

## 내용

[**애플 한 주가 고객에게 전달 되기까지**](https://www.notion.so/c6ea50cf7dfd45b8bc7384302ad41b83)

## 정리

### **동시성으로 부터 데이터를 안전하게 처리하는 방법**

**락**

동시성 제어를 위한 가장 보편적인 방법은 락을 통한 동시성 제어 방법이다. 그러나 여러 테이블에 대한 삽입 및 갱신이 일어나는 트랜잭션으로 대상 테이블에 대해 락을 잡는다면 성능 저하와 데드락을 피할 수 없다. 그리고 MSA에서 락을 이용한 동시성 제어는 서비스 간 높은 결합도를 유지하거나 비효율적인 자원 사용을 야기할 수 있다.

**분산 락**

보편적인 락 방식이 아닌 Redis 기반 분산락을 사용함으로써 모듈의 데이터베이스를 강제하지 않고 서비스 간 결합도도 느슨하게 유지할 수 있다. 또한 분산락은 여러 서버들에서 많은 요청이 발생하기 때문에 높은 처리량이 보장되어야 하는데 Redis는 메모리 기반 저장소이기 때문에 RDBMS를 사용하는 계좌락 방식에 비해 보다 높은 처리량을 제공하는 것 역시 장점이다.

**분산 락 주의점**

분산락은 모든 서버가 공통으로 사용하기 때문에 하나의 트랜잭션이 무한정 락을 소유하고 있을 경우 다른 서버들에서 데드락이 발생할 수 있다. 그렇기 때문에 분산락은 적절한 타임아웃 설정이 필요한데 **타임 아웃을 설정해도 갱신 타이밍에 유실 가능성이 있다.**

**갱신 유실 방지**

갱신 유실 방지는 원자적 연산 사용, 명시적 잠금, 갱신 손실 자동 감지, Compare-And-Set 연산 등 다양한 방법으로 방지가 가능하다.

**@OptimisticLocking**

JPA에서는 OptimisticLocking 애너테이션을 통해 간단하게 CAS(Compare-And-Set) 연산 구현이 가능하다. OptimisticLocking은 version을 통해 갱신 유실을 방지할 수 있다. 

### **네트워크 지연으로부터 안전하게 서비스**

해외에 있는 브로커와 통신하는 구간은 해외망으로 네트워크 지연이 빈번하게 발생하는 구간이다. 

브로커 요청 자체가 지연이 될 경우 매매 서버에 스레드까지 함께 블락킹되어 최악의 경우 모든 스레드가 행에 걸려 고객의 요청들을 받을 수 없는 상태가 될 수 있다.

**블락킹 해결**

토스증권에서는 고책의 요청을 받는 스레드와 브로커에게 요청하는 스레드를 분리하는 것으로 모든 스레드가 블락킹되는 이슈를 해결하고 있다. 

**비동기 처리**

브로커 통신 구간은 여전히 지연이 빈번하기 때문에 하나의 API에서 처리할 경우 상황에 따라 고객은 주문 응답을 기다리느라 다른 서비스를 이용할 수 없기 때문에 이 구간을 비동기로 처리해 고객 경험은 상승시키고 트랜잭션 시간을 최소화하고 있다.

**타임아웃**

TCP 기반 통신을 사용하게 되면 타임아웃이 발생하는 상황이 온다. 타임아웃이 발생한 데이터는 재시도 대상으로 판단하게 되는데 이 때, 멱등성이 있는 API를 설계하지 않는다면 정합성의 문제가 발생할 수 있다.

## 마지막으로

정합성과 신뢰성을 요구하는 증권 거래에서 토스 증권이 어떻게 대처를 하는지 알 수 있는 시간이었다. 최근 어떻게 하면 데이터의 정합성을 추구하며 신속한 데이터 처리를 하는지 궁금했었는데, 고민이 해결됐다. 추가적으로 레디스를 이용해 분산락을 활용하고, 이벤트 기반 아키텍처 설계로 확장성있는 구조는 정말 대단했다. 마지막 브로커 의존성 격리하는 부분이 정말 좋은 내용이라 있는 그래도 읽는 것이 좋아보여 따로 요약하지 않았다. 최근 프로젝트를 진행하면서 배포부터 데이터의 신뢰성 등 고민이 되는 부분이 많았는데, 어느 정도 해결이 됐다. 나중에 프로젝트를 설계하면서 진지하게 고려해보며 정리한 내용을 다시 읽는 시간을 가져야겠다.