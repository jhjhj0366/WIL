# HTTP 2.0

## 추가 사항
- **Request multiplexing(요청 다중화)**
	- HTTP 1.1은 순차적으로 기능하는 프로토콜이어서 한 번에 하나의 요청을 보낼 수 있지만, HTTP 2.0에서는 비동기적으로 요청을 보내고 응답을 받을 수 있다. 이 방식을 이용해 단일 연결을 사용해 동시에 여러 요청을 수행할 수 있다.
- **Request prioritization(요청 우선 순위 지정)**
	- HTTP 2.0을 사용하면 일괄 요청에서 숫자 우선 순위를 설정할 수 있다. 따라서 JS 파일보다 먼저 웹 페이지 CSS를 가져오는 것과 같이 응답을 예상하는 순서로 지정할 수 있다.
- **Automatic compressing(자동 압축)**
	- 이전 버전의 HTTP 1.1 에서는 요청 및 응답 압축을 명시적으로 요구해야 했지만, HTTP 2.0에서는 자동으로 GZip 압축을 실행한다.
- **Connection reset(연결 재설정)**
	- 서버와 클라이언트 간 연결을 닫고 즉시 새 연결을 열 수 있는 기능이다.
- **Server push**
	- 많은 요청을 받는 서버를 피하기 위해 HTTP 2.0은 서버 푸시 기능을 도입했다. 이를 통해 서버는 곧 요청될 리소스를 예측한다. 따라서 서버는 이러한 리소스를 클라이언트 캐시에 미리 푸시한다.
- 추가적인 기능
	- HTTP 2.0은 이전 HTTP 일반 텍스트 버전을 대체하는 바이너리 프로토콜이 되었다. 요약하면 HTTP 2.0은 마지막 HTTP 버전의 문제와 한계를 해결하기 위한 개선 패치이다.

## 추가 설명

### 요청 다중화
HTTP/1.x 프로토콜의 제약을 제거하여 동일한 연결을 통해 병렬 요청을 수행할 수 있다.

### 순위를 지정하는
브라우저 또는 클라이언트가 요구 사항 및 하드웨어 제약 조건에 대한 정보를 서버에 사전에 전달할 수 있도록 도입

### GZip
헤더를 압축한다. 이는 요청 집합 간에 유사한 경우가 많기 때문에 전송되는 데이터의 중복 및 오버헤드를 제거한다.

### 연결 재설정하는 이유

### 푸시는 어떻게 이뤄지는거지?
헤더를 압축합니다. 이는 요청 집합 간에 유사한 경우가 많기 때문에 전송되는 데이터의 중복 및 오버헤드를 제거한다. 이를 통해 서버는 서버 푸시라는 메커니즘을 통해 클라이언트 캐시에 데이터를 채울 수 있다.

### 바이너리 프로토콜이 의미하는 것
수동으로 읽고 만들 수 없다. 이러한 장애물에도 불구하고 개선된 최적화 기술을 구현할 수 있다.



> HTTP 2.0은 트래픽이 많은 웹 사이트는 데이터 전송 오버헤드와 후속 예산을 절약하기 위해 가장 빠른 채택을 보였다.